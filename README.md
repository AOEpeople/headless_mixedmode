# TYPO3 Extension "headless_mixedmode" - Use headless mixed with fluid_styled_content

Headless_mixedmode allows you to gracefully migrate your TYPO3 to headless output rendering.
No need to perform a single big leap.

Fluid_styled_content and headless are put on different typeNums and then the desired output
format can be chosen for example via a specified url ending.

## Features
- Replace _contentRenderingTemplate_ of fluid_styled_content and headless with typeNum aware variant
- Add output support for CType list (eg. extbase plugins)
- Add support for pi_flexform decoding (eg. custom content elements, dce et al.)

## Requirements
Extension requires TYPO3 in at least 9.5 along with
fluid_styled_content and [headless](https://github.com/TYPO3-Initiatives/headless)

## Installation
Install extension using composer\
``composer require aoe/headless_mixedmode``

Optionally install [typoscript_rendering](https://github.com/helhum/typoscript_rendering) to support ``INT_SCRIPT`` in plugin output\
``composer require helhum/typoscript-rendering``

Then, you must remove all direct usage of fluid_styled_content and headless typoscript templates.
Either used via template includes or included directly from your very own typoscript.

Place the headless_mixedmode typoscript at the same location where your fluid_styled_content/headless was.

You can configure three different typeNums:
- config.headless.type.fluid_styled_content - typeNum for fluid_styled_content, set to 0 as default page
- config.headless.type.headless - typeNum for headless, set to 9
- config.headless.type.headless_menu - typeNum for headless menu, set to 834

Configure your site config.yaml to use the typeNum via _PageTypeSuffix_ route enhancer. 
```
routeEnhancers:
  PageTypeSuffix:
    type: PageType
    default: '.html'
    map:
      '.html': 0
      '.json': 9
      'menu.json': 834
```

### CType list rendering
_Aoe\HeadlessMixedmode\Frontend\DataProcessing\ListTypeProcessor_ switches the extbase default format to json.
If your plugin is aware of the JSON output format, its output will be structured like this
```
{
  "page": {},
  "content": {
    "colPos0": [
      {
        "id": 2,
        "pid": 5,
        "type": "project_name",
        "colPos": 0,
        "categories": "",
        "appearance": {
          "layout": "default",
          "frameClass": "default",
          "spaceBefore": "",
          "spaceAfter": ""
        },
        "content": {
          "linkToProductOverview": "\/path\/overview.html",
          "invalidAddress": "<p>RTE text<\/p>",
          "notAvailable": "<p>RTE text<\/p>",
          "linkToCheckout": "\/path\/checkout.html",
        }
      }
    ]
  }
}
```
(Currently all links are rendered with the default page suffix!)\
Easiest way to reach JSON output for extbase plugins is to create a view named after the controller.
So for ``Vendor\Extension\Controller\MyController`` with a ``FirstAction`` you can create
a ``Vendor\Extension\View\My\FirstJson`` which can be as simple as
```
<?php
namespace Vendor\Extension\View\My;

use TYPO3\CMS\Extbase\Mvc\View\JsonView;

class FirstJson extends JsonView
{

}
```
If nothing else is configured this will render JSON from the variable ``value`` per default.

Or you could create separate templates with a .json ending and fiddle around with escaping the curly braces from fluid.

If the output of your plugin does not start with ``{`` it will be considered as a simple string and be structured like this
```
{
  "page": {},
  "content": {
    "colPos0": [
      {
        "id": 8,
        "pid": 7,
        "type": "plugin_name",
        "colPos": 0,
        "categories": "",
        "appearance": {
          "layout": "default",
          "frameClass": "default",
          "spaceBefore": "",
          "spaceAfter": ""
        },
        "content": {
          "text": "<p><strong>Sorry, the requested view was not found.<\/strong><\/p>\n<p>The technical reason is: <em>No template was found. View could not be resolved <\/p>"
        }
      }
    ]
  }
}
```
The example above does not show the real output, but only the error message if the plugins does not
support json output.
To change the default json output for plugins set the desired format via typoscript\
``tt_content.list.20.projectorderconfiguration_projectorderconfiguration.headlessMixedFormat = html``\
The output now contains the real html content.
```
{
  "page": {},
  "content": {
    "colPos0": [
      {
        "id": 8,
        "pid": 7,
        "type": "plugin_name",
        "colPos": 0,
        "categories": "",
        "appearance": {
          "layout": "default",
          "frameClass": "default",
          "spaceBefore": "",
          "spaceAfter": ""
        },
        "content": {
          "text": "<!-- This is the content generated by the plugin -->"
        }
      }
    ]
  }
}
```
 
If your plugin produces non cacheable output as an ``INT_SCRIPT`` a reference to the content via the
typoscript_rendering plugin will be generated and be structured like this
```
{
  "page": {},
  "content": {
    "colPos0": [
      {
        "id": 2,
        "pid": 5,
        "type": "project_name",
        "colPos": 0,
        "categories": "",
        "appearance": {
          "layout": "default",
          "frameClass": "default",
          "spaceBefore": "",
          "spaceAfter": ""
        },
        "content": {
          "intScript": "\/path\/plugin.json?tx_projectwppvp_wppvp%5Bformat%5D=json&tx_typoscriptrendering%5Bcontext%5D=%7B%22record%22%3A%22tt_content_2%22%2C%22path%22%3A%22tt_content.list.20.projectwppvp_wppvp%22%7D&cHash=..."
        }
      }
    ]
  }
}
```
(The content at the intScript URL will only be rendered when helhum/typoscript-rendering is installed!)

If your plugin is just a glorified content element maybe the easiest way would be to us the pi_flexform field contents.
```
{
  "page": {},
  "content": {
    "colPos0": [
      {
        "id": 2,
        "pid": 5,
        "type": "project_name",
        "colPos": 0,
        "categories": "",
        "appearance": {
          "layout": "default",
          "frameClass": "default",
          "spaceBefore": "",
          "spaceAfter": ""
        },
        "flexForm": {
          "settings": {
            "linkToVp": 5,
            "linkToProductOverview": 6,
            "invalidAddress": "<p>RTE text</p>",
            "noProductsAvailable": "<p>RTE text</p>",
            "linkToCheckout": 8,
            "linkToProductConfig": 7
          }
        }
      }
    ]
  }
}
```
(Be aware that the page ids are not rendered into proper links!)

### Custom content types
The best way to access your custom content depends on your choice of data storage.
If you add your fields via TCA additions you can put them individually into the content via the standard
JSON fields properties of the headless extension.

For pi_flexform based content types the output will be added by
_Aoe\HeadlessMixedmode\Frontend\DataProcessing\FlexFormProcessor_ and looks like
```
{
  "page": {},
  "content": {
    "colPos0": [
      {
        "id": 109,
        "pid": 45,
        "type": "dce_content_element",
        "colPos": 0,
        "categories": "",
        "appearance": {
          "layout": "default",
          "frameClass": "default",
          "spaceBefore": "",
          "spaceAfter": ""
        },
        "flexForm": {
          "settings": {
            "position": "Some headline",
            "text": "<p>Some RTE text<\/p>"
          }
        },
        "content": {}
      }
    ]
  }
}
```

For proper output of DCE elements you have to disable the ``direct output`` option for the content elements.

## Trouble Shooting

If the JSON output of the content does not contain the proper ``colPosX`` entries or the entries are all empty
you can get deeper insights with debugging \FriendsOfTYPO3\Headless\Utility\ContentUtility::groupContent.
The content is split at ``###BREAK###``. This fails most often when one of the content elements on the page
produces invalid output.